function [out1,out2,out3,out4]=myhpellip_z(freq,order,ripple,stopDB,zQ)%myhpellip_z creates a high-pass elliptic filter with useful input parameters% sys=myhpellip_z(freq,order,ripple,stopDB,zQ)%   returns the transfer function for a high pass elliptical filter%   with unity gain, knee at 'freq', with 'order' poles%   ripple DBs of ripple in the passband, and a%   stopband which is stopDB DBs down. %   Brian Lantz% % if called with two output args, returns numerator and denominator of tf, as% [num,den]=myhpellip_z(freq,order,ripple,stopDB)%% $Id: myhpellip_z.m 7958 2014-02-26 01:19:01Z jeffrey.kissel@LIGO.ORG $% modified BTL Jan 5,2000 to return a system, not a numerator/ denominatorif ( (order<2) | (order>3) )	sprintf('myhpellip_z only works for order 2 and 3')	if nargout==1		out1=myellip(freq,order,ripple,stopDB);	else		[out1,out2]=myellip(freq,order,ripple,stopDB);	end	returnend[ellZ, ellP, K]=ellip(order,ripple,stopDB,1,'high','s');ellZ = sort(ellZ);ellZsc=2*pi*freq*ellZ;Zsc         = -abs(2*pi*freq*max(ellZ));    % freq of the zeroellZsc_temp = Zsc*[1 + zQ*i, 1 - zQ*i]/sqrt(1+zQ^2);ellZsc(end-1) = ellZsc_temp(1);ellZsc(end) = ellZsc_temp(2);ellPsc=2*pi*freq*ellP;diff=length(ellP)-length(ellZ);gain=(2*pi*freq)^diff;switch nargout    case 1	out1=zpk(ellZsc,ellPsc, K*gain);    case 2	[out1,out2]=zp2tf(ellZsc,ellPsc, K*gain);    case 4        out1 = zpk(ellZsc,ellPsc, K*gain);        out2 = transpose(ellZsc) / (-2*pi); % [Hz]        out3 = transpose(ellPsc) / (-2*pi); % [Hz]        out4 = K*gain;    otherwise        disp('output can either be')        disp('nargout == 1: out = cont. zpk object of filter')        disp('nargout == 2: out1 = NUM, out2 = DEN (i.e. output of zp2tf)')        disp('nargout == 4: out1 = cont. zpk object of filter, out2 = zeros [Hz], out3 = poles [Hz], out4 = gain')end